p = print
inp = input
'''                          ========== Встроенные функции ========== '''
# print()
# len()
# input()
# divmod()
# id()
# range()
'''                          ========================================== '''
''' lambda ''' # анонимная функция (та же самая функция, только без имени)

# def func(a,b): return a + b
# p(func(2,3))

'''                          ========================================== '''

# lambda параметры: что функция должна возвращать
# a = lambda a,b: a+b
# p(a(5,2))
'''                          ========================================== '''
# x = lambda a,b,c: (a*b)%c
# p(x(3,5,2))

# x = lambda a,b,c: (a**10,b**2,c**3)
# p(x(3,5,2))
'''                          ========================================== '''
''' Пример, как мы можем достать все ключи с помощью lambda'''
# get_keys = lambda dict_: dict_.keys()
# dct = {1:'Hello', 2:"Ola Amigo Cepasso ", 3: 'Good Game'}
# p(get_keys(dct))
''' Или как достать последний элемент списка '''
# list = [1,2,3,4,5,6]
# get_element = lambda list_: list_[-1]
# p(get_element(list))
''' Или как возвести число в квадрат '''
# qv = lambda a:a**2
# p(qv(5))
'''                          ===================== map ===================== '''
# map (func, iterable) -> применят функцию к каждому элементу итерируемого обьекта
# map_ = map(int,['1','2','3'])
# p(set(map_))

# a = range(10)
# p (list(a))
''' map - Подвид цикла, т.е. он достает по очереди каждый элемент, и выполняет свои махинации'''
# list_ = [1,2,3,4,5,6,7,8,9]
# def f(number):
#     return number**2
# a = map(f,list_)
# p(list(a))
'''                          ===================== map =====================                     '''
''' Так же можно задействовать две функции подряд, из нижнего кода, мы вынесли отрицательные числа и положительные '''
# list_ = [1,-3,100,-44]
# list_2 = list(map(lambda x:x<0,list_))
# p(list_2)
'''                          ===================== map ===================                      '''
# func = lambda num:num +1
# res = []
# list_ = [1,2,3,4,5,6,7]
# for element in list_:
#     res.append(func(element))
# p (res)
'''                          ===================== filter =====================                  '''
''' Она также является функцией первого порядка, потому что принимает в себя функцию '''
# filter (func,iterable )
''' Возвращает генератор, то есть мы должны будем оборачивать либо в список сет и тд '''
''' Фильтрует если функция возвращает True '''
''' НАПРИМЕР!!! '''
# def filter_nums(number):
#     if number % 2 == 0:
#         return True
# bum = lambda num: num%2==0
# res =list(filter(lambda num:num%2==1, [1,2,3,4,5,6,7,8]))
# p(res)

# list_ = ['Эртай', 'Тима',"Айкол", "Ислам", "Айбек"]
# Glas = ['А',"У","И","Э","Ю","Я"]
# res = list(filter(lambda num:num[0]in Glas,list_))
# print(res)
'''                          ===================== reduse =====================                  '''
''' Первым делом ее нужно импортировать с бибилиотеки functools '''
from functools import reduce
#reduce (func,iterable)
''' Принимает в себя функцию и итерируемый обьект, и возвращает один результат  '''
'''                          ===================== reduse =====================                  '''
# (sum(), min(),max())

# list_ = [1,2,3,4,5,6]
# res = reduce(lambda x,y:x+y,list_)
# p(res)

'''                          ===================== reduse =====================                  '''

# list_ = [1,2,3,4,5,6]
# res = reduce(lambda x,y:x*y,list_)
# p(res)
'''                          ===================== reduse =====================                  '''

# list_ = [1,2,3,4,5,6,-23,-100]
# min_ = reduce(lambda small,x:small if (small>x)else x,list_)
# p(min_)
# ''' БОЛЬШЕ МЕНЬШЕ'''
# list_ = [1,2,3,4,5,6,-23,-100]
# min_ = reduce(lambda small,x:small if (small>x)else x,list_)
# p(min_)
''' =================== enumerate(iterable, [start - число, по дефолту 0]) ===================== '''
''' возвращает генератор в котором каждый элемент, это - tuple, состоящий из числа и самого элемента'''

''' Нумерует элементы '''
list_ = ['a','b','c','d']
# for element in enumerate(list_,1):
#     p(element)
''' #============---------------------------============# '''
# for a,b in enumerate(list_):
#     print (f'index - {a}, element - {b}')
''' #============---------------------------============# '''
# for i in enumerate(list_[1:]):
#     print(i)
'''        #============------------- zip(iterable,iterable(неогр)) --------------============# '''
# При помощи этой функции мы соеденяем эти последовательности и возвращает tuple 
# list1 = [1,2,3,4,5,6]
# list2 = ['a','b','c']
# p(dict(zip(list1,list2)))
# p(list(zip(list1,list2)))
''' #============---------------------------============# '''
# list3 = [1,2,3,45,67,65,3123,23,23]
# list4 = [0,0,0,0,0,0,00,0,0,0,0]
# list5 = ['a','v','b','x','v','c','as']
# print(list(zip(list3,list4,list5)))
''' #============-------------- Задачки -------------============# '''
# Изменить тип данных значений словаря 
# dict_ = {1:2,2:3,3:4,4:5}
# dict_ = {k: str(v) for k, v in dict_.items()}
# p(dict_)

# res = list(map(str,dict_.values()))
# dict_2 = zip(dict_.keys(),res)
# p(dict(dict_2))
''' #============---------------------------============# '''
# При помощи map() изменить список так что бы там лежали слова четное нечетное
list_ = [1,2,3,4,5,6,7,8]

a = '2 3 4'
b = tuple(map(int, a.replace(' ', '')))
def two():
    global d
    global g
    d = b[0]
    g = b[1]
two()
print (d,g)
